================================================================================
                   TEAM SERVICE MIGRATION - EXECUTIVE SUMMARY
================================================================================

FILE LOCATION
/Users/indiedevhipps/Documents/ElohimOS/apps/backend/api/team_service.py (5,145 LOC)

================================================================================
                            KEY FINDINGS
================================================================================

1. PYDANTIC MODELS: 76 total
   - Scattered throughout the file
   - Organized by Phases 3-6
   - Need centralization into api/schemas/team_models.py

2. API ENDPOINTS: 50+ total
   - Organized as single router
   - Cover 8 functional domains
   - Need reorganization into api/routes/team.py

3. BUSINESS LOGIC: TeamManager class
   - 62 methods
   - ~2,800 LOC
   - Well-structured by domain
   - Should be isolated in api/services/team.py

4. EXTERNAL DEPENDENCIES: 3 total (all eager imports)
   - permission_engine: Used in @require_perm decorators
   - audit_logger: Used in all mutations (audit_log_sync)
   - rate_limiter: Used for brute-force protection
   - None are lazy import candidates

5. DATABASE: 9 existing tables + 6 new tables needed
   - Existing: teams, team_members, invite codes, promotions, temp promos
   - New: workflow_permissions, queues, queue_permissions, god_rights, vault_items, vault_permissions

================================================================================
                     FUNCTIONAL DOMAINS (8 AREAS)
================================================================================

DOMAIN 1: Core Team Management (7 endpoints)
├─ Team CRUD operations
├─ Member listing
├─ Invite code management
└─ Models: CreateTeamRequest, TeamResponse, InviteCodeResponse, etc.

DOMAIN 2: Member Management (5-6 endpoints)
├─ Role changes (with validation)
├─ Member removal (with permission cleanup)
├─ Job role assignment
└─ Models: UpdateRoleRequest, UpdateRoleResponse, UpdateJobRoleRequest, etc.

DOMAIN 3: Join Team & Invites (2 endpoints)
├─ Team joining via invite code
├─ Brute-force protection (10 req/60s per IP)
└─ Models: JoinTeamRequest, JoinTeamResponse

DOMAIN 4: Promotion & Admin Failsafe (8-10 endpoints)
├─ Auto-promotion (7+ days)
├─ Instant promotion (with password verification)
├─ Delayed promotion (21-day security delay)
├─ Admin offline failsafe (temporary emergency promotion)
├─ Heartbeat tracking for super admin online status
└─ Models: AutoPromoteResponse, InstantPromoteRequest, DelayedPromoteRequest, etc.

DOMAIN 5: Workflow Permissions (4-5 endpoints)
├─ Grant/revoke workflow permissions
├─ Permission checking with default fallbacks
├─ Support for role, job_role, and user-level grants
├─ Permission types: view, edit, delete, assign
└─ Models: AddWorkflowPermissionRequest, WorkflowPermissionGrant, etc.

DOMAIN 6: Queue Management (6-7 endpoints)
├─ Queue creation with custom types
├─ Access control (view, manage, assign)
├─ Support for role, job_role, and user-level access
├─ Queue types: patient, medication, pharmacy, counseling, emergency, custom
└─ Models: CreateQueueRequest, AddQueuePermissionRequest, etc.

DOMAIN 7: God Rights / Founder Rights (5 endpoints)
├─ Grant/revoke highest authority level
├─ Delegation support
├─ Optional auth_key security
├─ Revocation tracking
└─ Models: GrantGodRightsRequest, RevokeGodRightsRequest, etc.

DOMAIN 8: Team Vault (8-9 endpoints)
├─ Encrypted document storage (AES with team-specific keys)
├─ Item types: document, image, file, note, patient_record
├─ Permission-based access control
├─ Update and delete operations
└─ Models: CreateVaultItemRequest, VaultItemInfo, VaultItemDetail, etc.

================================================================================
                     MIGRATION COMPLEXITY LEVELS
================================================================================

LOW COMPLEXITY (Straightforward extraction)
├─ Core team CRUD operations
├─ Basic member management
├─ Job role management
└─ Estimated effort: 1-2 hours

MEDIUM COMPLEXITY (Some logic refactoring)
├─ Invite code validation with brute-force protection
├─ Workflow permission checking with defaults
├─ Queue access control logic
├─ Vault encryption/decryption helpers
└─ Estimated effort: 2-3 hours

HIGH COMPLEXITY (Complex multi-step processes)
├─ Guest auto-promotion with eligibility checks
├─ Instant promotion with auth validation
├─ Delayed promotions with scheduled execution
├─ Admin offline failsafe with temporary promotions
├─ Permission checking with nested conditionals
└─ Estimated effort: 3-4 hours

================================================================================
                    RECOMMENDED MIGRATION ORDER
================================================================================

STEP 1: Create api/schemas/team_models.py (~1-2 hours)
├─ Extract all 76 Pydantic models
├─ Organize into 8 logical domain groups
├─ Add comprehensive docstrings
└─ Import only: from pydantic import BaseModel, Optional
└─ Result: 500-600 LOC

STEP 2: Create api/services/team.py (~3-5 hours)
├─ Move TeamManager class (62 methods)
├─ Move helper functions (_get_app_conn, is_team_member, require_team_admin)
├─ Import models from api/schemas/team_models
├─ Import external deps: permission_engine, audit_logger, rate_limiter
└─ Result: 2,000-2,500 LOC

STEP 3: Create api/routes/team.py (~2-4 hours)
├─ Extract all 50+ endpoints
├─ Organize into 8 functional area sections
├─ Make endpoints thin (just validation + service call + response)
├─ Import from api/services/team and api/schemas/team_models
└─ Result: 1,500-2,000 LOC

STEP 4: Update imports in main.py (~30 minutes)
├─ Remove: from api.team_service import router as team_router
├─ Add: from api.routes.team import router as team_router
├─ Verify all imports resolve correctly
└─ Test basic import without running

STEP 5: Database schema migrations (~1 hour)
├─ Create 6 new tables for workflow, queue, god_rights, vault
├─ Add proper indexes for performance
├─ Create migration script for safe deployment
└─ Test migration on development database

STEP 6: Testing & Validation (~2-3 hours)
├─ Run unit tests on service layer
├─ Run integration tests on all endpoints
├─ Verify all 8 functional domains work correctly
├─ Check database schema changes
└─ Performance baseline testing

TOTAL ESTIMATED EFFORT: 12-18 hours (1.5-2 days for experienced developer)

================================================================================
                       EXTERNAL DEPENDENCIES
================================================================================

PERMISSION ENGINE
├─ Import: from permission_engine import require_perm, get_permission_engine
├─ Usage Pattern:
│  ├─ @require_perm("system.manage_users") - team creation
│  ├─ @require_perm("team.use") - most team operations
│  └─ get_permission_engine().invalidate_user_permissions(user_id) - after mutations
├─ Recommendation: Keep as eager import (decorator usage)
└─ Location in split: api/services/team.py for method calls

AUDIT LOGGER
├─ Import: from audit_logger import audit_log_sync, AuditAction
├─ Usage Pattern:
│  ├─ audit_log_sync(user_id=..., action=..., resource=..., resource_id=..., details=...)
│  ├─ Actions: team.created, invite.created, member.role.changed, member.removed, member.joined
│  └─ Every mutation gets logged for compliance
├─ Recommendation: Keep as eager import (frequent usage)
└─ Location in split: api/services/team.py for all mutations

RATE LIMITER
├─ Import: from rate_limiter import rate_limiter, get_client_ip
├─ Usage Pattern:
│  ├─ rate_limiter.check_rate_limit(f"team:join:{client_ip}", max_requests=10, window_seconds=60)
│  └─ Brute-force protection on invite code validation
├─ Recommendation: Keep as eager import (route-level usage)
└─ Location in split: api/routes/team.py for rate limiting checks

NONE ARE LAZY IMPORT CANDIDATES because:
1. Used at module load time (decorators)
2. Used in high-traffic endpoints
3. Import overhead would exceed benefits
4. Required for security (permission checks, rate limiting)

================================================================================
                       DATABASE SCHEMA CHANGES
================================================================================

NEW TABLES TO CREATE (6 tables)

1. workflow_permissions
   ├─ Columns: id, workflow_id, team_id, permission_type, grant_type, grant_value, created_by, created_at
   ├─ Indexes: (workflow_id, team_id), (workflow_id, grant_type, grant_value)
   └─ Purpose: Control who can view/edit/delete/assign workflows

2. queues
   ├─ Columns: queue_id, team_id, queue_name, queue_type, description, created_by, created_at
   ├─ Indexes: (team_id, queue_type)
   └─ Purpose: Team queues for patient, medication, counseling, etc.

3. queue_permissions
   ├─ Columns: id, queue_id, team_id, access_type, grant_type, grant_value, created_by, created_at
   ├─ Indexes: (queue_id, access_type), (queue_id, grant_type, grant_value)
   └─ Purpose: Control who can view/manage/assign queue items

4. god_rights
   ├─ Columns: id, user_id, granted_at, granted_by, revoked_at, revoked_by, is_active, notes
   ├─ Indexes: (user_id, is_active)
   └─ Purpose: Track Founder Rights (highest authority level)

5. vault_items
   ├─ Columns: item_id, team_id, item_name, item_type, encrypted_content, encryption_algorithm, mime_type, file_size, metadata, created_by, created_at, updated_by, updated_at
   ├─ Indexes: (team_id, item_type, created_by)
   └─ Purpose: Encrypted team document storage

6. vault_permissions
   ├─ Columns: id, item_id, team_id, permission_type, grant_type, grant_value, created_by, created_at
   ├─ Indexes: (item_id, permission_type), (item_id, grant_type, grant_value)
   └─ Purpose: Control who can view/edit/delete vault items

EXISTING TABLES (already in place)
├─ teams (team_id, name, description, created_at, created_by, is_active)
├─ team_members (team_id, user_id, role, job_role, joined_at, last_seen, is_active)
├─ invite_codes (code, team_id, created_at, expires_at, used, used_by, used_at)
├─ team_invites (invite_id, team_id, email_or_username, role, invited_by, invited_at, expires_at, status)
├─ invite_attempts (invite_code, ip_address, attempt_timestamp, success) - brute-force tracking
├─ delayed_promotions (team_id, user_id, from_role, to_role, scheduled_at, execute_at, executed, reason)
├─ temp_promotions (team_id, original_super_admin_id, promoted_admin_id, status, reason, approved_by)
└─ [2 more internal tables]

================================================================================
                         KEY INSIGHTS
================================================================================

1. WELL-ORGANIZED CODE
   ├─ Despite 5,145 lines, the code is logically well-organized
   ├─ Methods are grouped by functional area
   ├─ Separation of concerns is clear
   └─ Split will dramatically improve readability

2. SECURITY-FOCUSED
   ├─ Brute-force protection on invite codes
   ├─ Role-based access control at every step
   ├─ Audit logging on all mutations
   ├─ Encryption for vault items (team-specific keys)
   ├─ Permission system integration throughout
   └─ Decoy password delay for sensitive promotions

3. COMPLEX PROMOTION SYSTEM
   ├─ Multiple paths: auto, instant, delayed, temporary failsafe
   ├─ 21-day security delay for sensitive promotions
   ├─ Offline super admin failsafe with emergency temporary promotion
   ├─ Heartbeat tracking to determine online status
   ├─ This is the most complex domain in the file
   └─ Suggests security is a top priority

4. PERMISSION LAYERING
   ├─ System-level permissions (permission_engine)
   ├─ Team-level roles (super_admin, admin, member, guest)
   ├─ Job roles (doctor, nurse, pastor, etc.)
   ├─ Resource permissions (workflow, queue, vault item level)
   └─ This is a sophisticated permission model

5. THREE DEVELOPMENT PHASES
   ├─ Phase 3: App database migration
   ├─ Phase 5: Workflow/Queue permissions
   ├─ Phase 6: God rights + Vault
   └─ Clear progression of features

6. ENCRYPTION SUPPORT
   ├─ Vault items require team-specific encryption keys
   ├─ Support for algorithm specification in storage
   ├─ Metadata can also be encrypted
   └─ Compliance-focused (likely healthcare regulations)

================================================================================
                         DELIVERABLES
================================================================================

This analysis provides:

1. COMPREHENSIVE BREAKDOWN
   ├─ Full migration plan (1,098 lines)
   ├─ Quick reference guide
   ├─ Architecture diagrams
   ├─ Database schema details
   └─ Implementation timeline

2. ORGANIZED BY DOMAIN
   ├─ Models grouped by 8 functional areas
   ├─ Endpoints organized by domain
   ├─ Methods categorized by purpose
   └─ Clear separation of concerns

3. ACTIONABLE INSIGHTS
   ├─ Complexity levels for each domain
   ├─ Estimated effort for migration
   ├─ Step-by-step implementation guide
   ├─ Database migration scripts needed
   └─ Testing checklist

4. DEPENDENCIES MAPPED
   ├─ External imports identified
   ├─ Lazy import analysis completed
   ├─ No refactoring of dependencies needed
   ├─ All imports remain as-is
   └─ Security implications reviewed

================================================================================
                           NEXT STEPS
================================================================================

1. Review this analysis for accuracy
2. Verify all 8 functional domains match your understanding
3. Confirm the estimated effort aligns with your team capacity
4. Create implementation schedule based on timeline
5. Begin with Step 1: Create api/schemas/team_models.py
6. Follow the 6-step migration plan in order
7. Test thoroughly at each step
8. Deploy with database migration script

Expected outcome: 
- Dramatically improved code readability
- Easier testing and maintenance
- Clear separation of concerns
- Better code reusability
- Compliance with clean architecture principles

================================================================================
